# This file's main purpose is as a place to temporarily add new
# language tests during development without having to depend on
# a new NetLogoHeadlessTests artifact.  if the test you add
# here should pass on JVM NetLogo too, then before committing
# and pushing, please add the test to the NetLogo repo instead.

Smoke
  2 + 2 => 4
  netlogo-web? => true

MapExtension
  extensions [nlmap]
  globals [ basic ls str ]
  O> set basic (nlmap:from-list [["apples" 4] ["oranges" 6]])
  nlmap:to-list (nlmap:from-list []) => []
  nlmap:to-list (nlmap:from-list [["apples" 4] ["oranges" 6]]) => [["apples" 4] ["oranges" 6]]
  nlmap:to-list (nlmap:add basic "grapes" 9001) => [["apples" 4] ["oranges" 6] ["grapes" 9001]]
  nlmap:to-list (nlmap:remove basic "apples") => [["oranges" 6]]
  nlmap:to-list (nlmap:remove basic "oranges") => [["apples" 4]]
  nlmap:to-list (nlmap:remove basic "grapes") => [["apples" 4] ["oranges" 6]]
  nlmap:to-list (nlmap:remove (nlmap:add basic "grapes" 9001) "grapes") => [["apples" 4] ["oranges" 6]]
  nlmap:is-map? basic => true
  nlmap:is-map? [] => false
  nlmap:is-map? 49 => false
  nlmap:is-map? true => false
  nlmap:is-map? false => false
  nlmap:is-map? "string" => false
  nlmap:is-map? nobody => false
  nlmap:get basic "apples" => 4
  nlmap:get basic "oranges" => 6
  nlmap:get (nlmap:remove basic "apples") "oranges" => 6
  nlmap:get (nlmap:add basic "grapes" 9001) "grapes" => 9001
  nlmap:get (nlmap:add basic "grapes" 9001) "oranges" => 6
  nlmap:get (nlmap:remove (nlmap:add basic "grapes" 9001) "grapes") "apples" => 4
  nlmap:get (nlmap:remove (nlmap:add basic "grapes" 9001) "grapes") "oranges" => 6
  nlmap:get (nlmap:remove (nlmap:add basic "grapes" 9001) "apples") "grapes" => 9001
  nlmap:get (nlmap:remove (nlmap:add basic "grapes" 9001) "apples") "oranges" => 6
  codap:init ([[] ->]) => COMPILER ERROR No such primitive: CODAP:INIT
  O> set basic nlmap:from-json "{ \"url\": \"url\", \"obj\": { \"val1\": 100, \"val2\": \"apples\", \"val3\": [ 4, 5, 6 ] } }"
  O> set ls nlmap:to-list basic
  item 0 ls => ["url" "url"]
  item 0 item 1 ls => "obj"
  nlmap:to-list (item 1 item 1 ls) => [["val1" 100] ["val2" "apples"] ["val3" [4 5 6]]]
  O> set str nlmap:to-urlenc (nlmap:from-list [["apples" 4] ["oranges" "6 w/ spaces & 'spec.' chars"]])
  str => "apples=4&oranges=6%20w%2F%20spaces%20%26%20'spec.'%20chars"
  O> set str nlmap:to-json basic
  str => "{\"url\":\"url\",\"obj\":{\"val1\":100,\"val2\":\"apples\",\"val3\":[4,5,6]}}"

CodapExtension
  extensions [codap nlmap]
  O> codap:init ([[] ->])
  O> codap:call (nlmap:from-list [])

LoggingExtension
  extensions [logging]
  globals [apples oranges grapes]
  to do-logging-batch logging:log-message "hi" logging:log-message (word "ticks: " ticks) (logging:log-globals) (logging:log-globals "oranges" "apples" "grapes") (logging:log-globals "grapes" "oranges") tick end
  O> reset-ticks set apples 91 set grapes "howdy" set oranges false
  O> do-logging-batch
  logging:all-logs => ["hi" "ticks: 0" "apples: 91\noranges: false\ngrapes: \"howdy\"" "oranges: false\napples: 91\ngrapes: \"howdy\"" "grapes: \"howdy\"\noranges: false"]
  O> do-logging-batch
  logging:all-logs => ["hi" "ticks: 0" "apples: 91\noranges: false\ngrapes: \"howdy\"" "oranges: false\napples: 91\ngrapes: \"howdy\"" "grapes: \"howdy\"\noranges: false" "hi" "ticks: 1" "apples: 91\noranges: false\ngrapes: \"howdy\"" "oranges: false\napples: 91\ngrapes: \"howdy\"" "grapes: \"howdy\"\noranges: false"]
  O> logging:clear-logs
  O> do-logging-batch
  logging:all-logs => ["hi" "ticks: 2" "apples: 91\noranges: false\ngrapes: \"howdy\"" "oranges: false\napples: 91\ngrapes: \"howdy\"" "grapes: \"howdy\"\noranges: false"]
  O> logging:log-message "All done."
  logging:all-logs => ["hi" "ticks: 2" "apples: 91\noranges: false\ngrapes: \"howdy\"" "oranges: false\napples: 91\ngrapes: \"howdy\"" "grapes: \"howdy\"\noranges: false" "All done."]

MatrixExtension1
  extensions [matrix]
  globals [glob1 glob2 glob3]
  O> set glob1 matrix:from-row-list [[1 2 3] [4 5 6]]
  (word glob1) => "{{matrix:  [ [ 1 2 3 ][ 4 5 6 ] ]}}"
  matrix:pretty-print-text glob1 => "[[ 1  2  3 ]\n [ 4  5  6 ]]"
  matrix:dimensions glob1 => [2 3]
  matrix:get glob1 1 2 => 6
  O> matrix:set glob1 1 2 10
  (word glob1) => "{{matrix:  [ [ 1 2 3 ][ 4 5 10 ] ]}}"
  O> set glob2 matrix:make-identity 3
  (word glob2) => "{{matrix:  [ [ 1 0 0 ][ 0 1 0 ][ 0 0 1 ] ]}}"
  (word matrix:times glob1 glob2) => "{{matrix:  [ [ 1 2 3 ][ 4 5 10 ] ]}}"
  O> set glob3 (matrix:set-and-report glob2 1 1 -1)
  (word glob3) => "{{matrix:  [ [ 1 0 0 ][ 0 -1 0 ][ 0 0 1 ] ]}}"
  (word matrix:times glob1 glob3) => "{{matrix:  [ [ 1 -2 3 ][ 4 -5 10 ] ]}}"
  matrix:to-row-list (matrix:plus glob2 glob3) => [[2 0 0] [0 0 0] [0 0 2]]

Matrix_matrix-is-matrix
  extensions [ matrix ]
  matrix:is-matrix? 0 => false
  matrix:is-matrix? "hi" => false
  matrix:is-matrix? [[1 2 3][4 5 6]] => false
  matrix:is-matrix? matrix:make-identity 3 => true

Matrix_matrix-times-scalar
  extensions [ matrix ]
  globals [glob1]
  O> set glob1 matrix:from-row-list [[1 2 3] [4 5 6]]
  (word matrix:times-scalar glob1 -1) => "{{matrix:  [ [ -1 -2 -3 ][ -4 -5 -6 ] ]}}"
  (word glob1) => "{{matrix:  [ [ 1 2 3 ][ 4 5 6 ] ]}}"

Matrix_matrix-times
  extensions [ matrix ]
  globals [glob1 glob2]
  O> set glob1 matrix:from-row-list [[1 2 3] [4 5 6] [7 8 9]]
  (word (matrix:times 2 glob1 glob1)) => "{{matrix:  [ [ 60 72 84 ][ 132 162 192 ][ 204 252 300 ] ]}}"
  (word (matrix:times 2 glob1 glob1)) => "{{matrix:  [ [ 60 72 84 ][ 132 162 192 ][ 204 252 300 ] ]}}"
  (word (matrix:times matrix:make-identity 1 2 3)) => "{{matrix:  [ [ 6 ] ]}}"
  O> set glob2 matrix:from-row-list [[ 6 ]]
  (word (list matrix:times glob2 glob2 glob2)) => "[{{matrix:  [ [ 36 ] ]}} {{matrix:  [ [ 6 ] ]}}]"
  (word (2 matrix:* glob1 matrix:* glob1)) => "{{matrix:  [ [ 60 72 84 ][ 132 162 192 ][ 204 252 300 ] ]}}"

Matrix_matrix-plus
  extensions [ matrix ]
  globals [glob1]
  O> set glob1 matrix:from-row-list [[1 2 3] [4 5 6] [7 8 9]]
  (word (matrix:plus 1 glob1 glob1 glob1)) => "{{matrix:  [ [ 4 7 10 ][ 13 16 19 ][ 22 25 28 ] ]}}"
  (word (matrix:plus glob1 glob1 glob1)) => "{{matrix:  [ [ 3 6 9 ][ 12 15 18 ][ 21 24 27 ] ]}}"
  (word (matrix:plus glob1 glob1 glob1)) => "{{matrix:  [ [ 3 6 9 ][ 12 15 18 ][ 21 24 27 ] ]}}"
  (word (glob1 matrix:+ glob1 matrix:+ glob1)) => "{{matrix:  [ [ 3 6 9 ][ 12 15 18 ][ 21 24 27 ] ]}}"

Matrix_matrix-minus
  extensions [ matrix ]
  globals [glob1]
  O> set glob1 matrix:from-row-list [[1 2 3] [4 5 6] [7 8 9]]
  (word matrix:minus glob1 glob1) => "{{matrix:  [ [ 0 0 0 ][ 0 0 0 ][ 0 0 0 ] ]}}"
  (word matrix:minus glob1 1) => "{{matrix:  [ [ 0 1 2 ][ 3 4 5 ][ 6 7 8 ] ]}}"
  (word matrix:minus 1 glob1) => "{{matrix:  [ [ 0 -1 -2 ][ -3 -4 -5 ][ -6 -7 -8 ] ]}}"
  (word (matrix:minus glob1 glob1 glob1)) => "{{matrix:  [ [ -1 -2 -3 ][ -4 -5 -6 ][ -7 -8 -9 ] ]}}"
  (word (glob1 matrix:- glob1 matrix:- glob1)) => "{{matrix:  [ [ -1 -2 -3 ][ -4 -5 -6 ][ -7 -8 -9 ] ]}}"

Matrix_matrix:precedence
  extensions [ matrix ]
  globals [glob1]
  O> set glob1 matrix:from-row-list [[1 2 3] [4 5 6] [7 8 9]]
  (word (glob1 matrix:+ 2 matrix:* glob1)) => "{{matrix:  [ [ 3 6 9 ][ 12 15 18 ][ 21 24 27 ] ]}}"

Matrix_matrix-times-element-wise
  extensions [ matrix ]
  globals [glob1 glob2]
  O> set glob1 matrix:from-row-list [[1 2 3] [1 2 3]]
  (word (matrix:times-element-wise glob1 glob1 glob1)) => "{{matrix:  [ [ 1 8 27 ][ 1 8 27 ] ]}}"
  O> set glob2 matrix:from-row-list [[ 6 ]]
  (word (list matrix:times-element-wise glob2 glob2 glob2)) => "[{{matrix:  [ [ 36 ] ]}} {{matrix:  [ [ 6 ] ]}}]"

Matrix_dimensions
  extensions [matrix]
  matrix:dimensions matrix:from-row-list [[1 2 3] [4 5 6]] => [2 3]

Matrix_map
  extensions [matrix]
  globals [glob1 glob2]
  O> set glob1 matrix:from-row-list [[0 1 2 3 4] [5 6 7 8 9]]
  (word matrix:map ([x -> x ^ 2]) glob1) => "{{matrix:  [ [ 0 1 4 9 16 ][ 25 36 49 64 81 ] ]}}"
  O> set glob2 matrix:from-row-list [[9 8 7 6 5] [4 3 2 1 0]]
  (word (matrix:map ([[x y] -> x + y]) glob1  glob2)) => "{{matrix:  [ [ 9 9 9 9 9 ][ 9 9 9 9 9 ] ]}}"
  O> set glob2 matrix:from-row-list [[9 8 7 6] [4 3 2 1]]
  (word (matrix:map ([[x y]   -> x + y]) glob1  glob2)) => ERROR Extension exception: All matrices must have the same dimensions: the first was 2x5 and another was 2x4.
  (word (matrix:map ([[x y z] -> x + y]) glob1  glob2)) => ERROR Extension exception: Task expected 3 matrix inputs but only got 2.

Matrix_regress
  extensions [matrix]
  globals [glob1 glob2]
  O> set glob1 [20 25 28 32 35 39]
  O> set glob2 n-values length glob1 [x -> x]
  # The test below does not produce the exact same floating point math results as desktop, so we use a particular precision
  to-report nearly [pair] report (list (map [x -> precision x 13] (item 0 pair)) (item 1 pair)) end
  nearly matrix:regress matrix:from-column-list (list glob1 glob2) => [[20.6190476190476 3.6857142857143] [0.9953743395474031 238.83333333333331 1.1047619047619044]]
